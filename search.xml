<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[事件（十五）]]></title>
    <url>%2F2018%2F08%2F15%2F%E4%BA%8B%E4%BB%B6%EF%BC%88%E5%8D%81%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[事件：交互体验的核心功能事件绑定：（1）dom.onxxx = function (event) {执行语句}：兼容性很好，但是一个元素只能绑定一个处理程序基本等同于写在HTML行间上（句柄式的写法：在标签上写onclick = “点击执行语句”。）（2）dom.addEventListener(type, fn, false)：括号里是事件类型（字符串形式），执行函数，false；IE9以下不兼容，可以为一个事件绑定多个处理程序（3）dom.attachEvent(‘on’ + type, fn)：IE独有，一个事件同样可以绑定多个处理程序事件处理程序的运行环境：（1）dom.onxxx = function (event) {}：程序this指向是dom元素本身（2）dom.addEventListener(type, fn, false)：程序this指向是dom元素本身（3）dom.attachEvent(‘on’ + type, fn)：程序this指向window兼容性的addEvent(elem,type,handle)方法：1234567891011function addEvent(elem, type, handle) &#123; if(elem.addEventListener) &#123; elem.addEventListener(type,handle,false); &#125;else if(elem.attachEvent) &#123; elem.attachEvent(&apos;on&apos; + type,function() &#123; handle.call(elem); &#125;) &#125;else&#123; elem[&apos;on&apos;+ type] = handle; &#125;&#125; 解除事件绑定ele.onclick = false/‘’/null;ele.removeEventListener(type, fn, false);ele.detachEvent(‘on’ + type, fn);注:若绑定匿名函数，则无法解除，此时可以将函数引用写在外部，写好函数名。绑定和解除的事件类型，函数名，false必须完全一样。1234var div = document.getElementsByTagName(&apos;div&apos;)[0];div.addEventListener(&apos;click&apos;,test,fale);function test() &#123;console.log(&apos;a&apos;);&#125;div.removeEventListener(&apos;click&apos;,test,false); 事件处理模型：事件冒泡，事件捕获下面以一个例子讲述事件冒泡和事件捕获123456789101112131415161718&lt;div class = &quot;wrapper&quot;&gt; &lt;div class = &quot;content&quot;&gt; &lt;div class = &quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;var wrapper = document.getElementsByClassName(&apos;wrapper&apos;)[0];var content = document.getElementsByClassName(&apos;content&apos;)[0];var box = document.getElementsByClassName(&apos;box&apos;)[0];wrapper.addEventListener(&apos;click&apos;,function() &#123; console.log(&quot;wrapper&quot;);&#125;,false);content.addEventListener(&apos;click&apos;,function() &#123; console.log(&quot;content&quot;);&#125;,false);box.addEventListener(&apos;click&apos;,function()&#123; console.log(&quot;box&quot;);&#125;,false); 上述代码，点击结构的子元素，都会触发父级上的事件执行函数，冒泡和捕获的区别在于父级和子级事件绑定的执行函数的执行顺序。冒泡先执行子元素，捕获先执行父元素。（1）事件冒泡：结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）{子元素的事件绑定先执行}（2）事件捕获：结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素（事件源元素）。（自底向上）在事件绑定的方法中，将false改变成为true，则事件处理模型变为事件捕获。{父级的事件绑定先执行}div.setCapture();事件捕获，仅在IE上好使；div.releaseCapture();释放事件捕获的功能；（3）IE没有捕获事件，谷歌浏览器有，新版本的欧朋有事件捕获。触发顺序，先捕获，后冒泡。focus，blur，change，submit，reset，select 等事件不冒泡 事件对象事件绑定时传递的形参，我们不能传实参，但是系统会帮我们传一个事件对象（就是一个对象，上面有很多属性 ，每个属性都记载了这个事件发生时的关键性数据） event || window.event 用于IE事件源对象：event.target 火狐独有的；event.srcElement Ie独有的；这俩chrome都有 取消冒泡和阻止默认事件（1）取消冒泡：事件对象上的方法：W3C标准 event.stopPropagation();但不支持ie9以下版本；IE独有 event.cancelBubble = true;（2）取消冒泡的函数 stopBubble(event)1234567function stopBubble(event) &#123; if(event.stopPropagation) &#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; （3）阻止默认事件：默认事件 — 表单提交，a标签跳转，右键菜单等①return false; 以对象属性的方式注册的事件才生效，只有用于取消句柄式绑定事件的默认事件。②event.preventDefault(); W3C标注，IE9以下不兼容③event.returnValue = false; 兼容IE（4）阻止默认事件的函数 cancelHandler(event);1234567function cancleHandler(event) &#123; if(event.preventDefault) &#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 事件委托利用事件冒泡和事件源对象进行处理，优点是节省性能，不需要所有元素一个个绑定事件；灵活，当有新的子元素时不需要重新绑定事件。以下代码实现的功能是给ul中的所有li绑定事件，输出li上的文本：123456var ul = document.getElementsByTagName(&apos;ul&apos;)[0];ul.onclick = function(e) &#123; var event = e || window.event; var target = event.target || event.srcElement; console.log(target.innerText);&#125; 事件分类鼠标事件：（1）click（鼠标点击事件）、mousedown、mouseup：先down后up再click；（2）contextmenu（右键产生菜单事件），学习是为了取消菜单事件；（3）mousemove（鼠标移动事件）；（4）mouseover、mouseout（鼠标移入事件，鼠标移出事件）和mouseenter，mouseout功能相似（ES5的新方法）。（5）移动端用touchstart，touchmove，touchend。 区分左右键：事件对象上有button属性，属性值为0，则为左键，属性值为1,则为滚动轮，属性值为2，则为右键。DOM3标准规定：click事件只能监听左键，只能通过mousedown和mouseup来判断鼠标键。能触发右键的只能是后面两个。 解决mousedown和click的冲突：当某个按钮有点击跳转和拖拽的功能时，要区分是拖拽还是点击，此时可以用时间戳，down时获取一个时间，up时获取一个时间。判断时间的长短来区分。 键盘事件：（1）keydown keyup keypress：键盘按下，抬起，按住之后触发keydown &gt; keypress &gt; keyup，当不抬起键盘按键时，down和press交替连续触发。抬起触发up。press事件可以用来连续触发某个事件，例如射击游戏的连续开枪。（2）keydown和keypress的区别①keydown 可以响应任意键盘按键（除了fn这个辅助键），keypress只可以相应字符类键盘按键，即为阿斯特码表中有编码的按键才能监听press事件。②keypress返回ASCII码，保存在事件对象的charCode属性上，down的charCode属性是0。③keypress事件用于判断是哪个字符类按键。看事件对象上的charCode的属性值。keydown中事件对象上有个which属性，值对应108键的哪个键位，无法区分按键的大小写。（String上有个静态方法：String.fromCharCode();括号中填写阿斯特码，能将其转化为相应的字符） 文本操作事件：input：当input框绑定了oninput事件后，input框中的value值有变化，就会触发事件。change：当input框绑定了onchange事件后，对比聚焦和失去焦点后文本的变化，改变触发事件。focus，blur，聚焦和失去焦点时触发的事件。 窗体操作类(window上的事件)（1）scroll：当滚动条位置发生变化时触发的事件：123window.onscroll = function()&#123; console.log(window.pageXoffset + &quot;&quot; + window.pageYoffset);&#125; IE6无fixed定位，相对于可视区窗口位置不变的效果可以用absolute来实现，此时的top值为初始值加上滚动条滚动的距离。可以用scroll绑定事件，获取滚动条滚动的距离，并且赋给元素。使其位置相对于可视区窗口保持不变。 （2）load：加载完成后触发的事件。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期对象（十四）]]></title>
    <url>%2F2018%2F08%2F15%2F%E6%97%A5%E6%9C%9F%E5%AF%B9%E8%B1%A1%EF%BC%88%E5%8D%81%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Data的对象属性：data.constructor：返回对创建此对象的Data函数的引用（function Data(){ }）Data.prototype： 可以向对象添加属性。指向原型 Data的对象方法（1），Data()；返回当前的时间，单独执行返回当前详细时间的字符串格式。以下方法是data对象调用的方法，var data = New Data()；（2）getData()；从data对象中返回一个月中的某一天。（1 ~ 31）（3）getDay()；从data对象中返回一周中的某一天。（0 ~ 6）（4）getMonth()；从data对象中返回月份（0 ~11）要想与当前月份相同，得加一。（5）getFullYear()；getYear（）；从data对象中以四位数返回年份。（6）getHours()；返回data对象的小时（0 ~ 23）；（7）getMinutes()；返回data对象中的分钟（0 ~ 59）；（8）getSeconds()；返回data对象中的秒数（0 ~ 59）；（9）getMilliseconds()；返回data对象中的毫秒数（0 ~ 59）；（10）getTime()；返回1970年一月一日零刻到当前时刻的毫秒数；（11）Data.parse()；返回1970年一月一日零点到指定时间的毫秒数。（括号中填写指定时间）（12）setData()；设置data对象中的月的某一天（1 ~ 31）（13）setMonth()；设置data对象中月份（0 ~ 11）（14）setFullYear()；设置data对象中的年份（四位数字）（15）setHours()；设置小时；（16）setMinutes()；设置分钟；（17）setSeconds()；设置秒；（18）setMilliseconds()；设置毫秒；（19）setTime()；以毫秒设置data对象；（20）toString()；把data对象转化成字符串； 定时器 全局window上的方法，内部函数的this指向window。（1）setInterval 用法：setInterval(function() { 函数执行代码 },时间)；时间不准确（轮转时间片）function能用以字符串形式的执行语句替换；时间固定，不能以形参替换。（2）clearInterval()；清除定时器；（3）setTimeout()； 用法：setTimeout（function() {执行语句}，时间）；延迟多少时间执行一次，只执行一次；（4）clearTimeout()；清除定时器；当直接执行setTimeout中的语句时，清除定时器下面是手写的一个定时器，到三分钟停止1234567891011121314151617var minuteNode = document.getElementsByTagName(&apos;input&apos;)[0];var secondNode = document.getElementsByTagName(&apos;input&apos;)[1];var minute = 0;var second = 0;var timet = 0;temer = setInterval(function() &#123; second ++; if(second == 60) &#123; minute ++; second = 0; &#125; minuteNode.value = minute; secondNode.setAttribute(&apos;value&apos;,second); if(minute == 3)&#123; clearInterval(timer); &#125;&#125;,1000)]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>日期对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[脚本化css（十三）]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%84%9A%E6%9C%AC%E5%8C%96css%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[读写元素css属性（1）dom.style：返回类数组，名为CSSStyleDeclaration{内含所有dom元素能被赋值的css属性}css列表声明（2）dom.style.prop：可读写行间样式，没有兼容性问题，碰到float这样的关键字属性，前面应加css。eg:float — &gt; cssFloat复合属性必须拆解，组合单词变成小驼峰式写法。eg：background-color必须写成backgroundColor但对像border这样的属性，有borderWidth，borderStyle，拆开读写值。（现在一起读写也行，只是分开写更加规范而已）写入的值必须是字符串格式。eg：div.style.width = “200px”;将dom元素的宽度变为200像素。（3）以上方法只能读写行间的style属性上的值，当页面级的css或者外部文件引用的值与行间的冲突且行间的权重小，此时取值与实际的不相符合。可以用下面的查看最终展示的样式的值。 查询计算样式window.getComputedStyle(dom,null); 计算样式只读， 返回的css列表声明是最终展示的样式值。返回的计算样式的值都是绝对值，没有相对单位。IE8 及 IE8以下不兼容 查询样式（IE独有的属性）dom.currentStyle：计算样式只读，返回css列表声明。返回的计算样式的值不是经过转换的绝对值。兼容性方法：1234567function getStyle(elem,style) &#123; if(window.getComputedStyle) &#123; return window.getComputedStyle(elem,null)[style]; &#125;else&#123; return elem.currentStyle[style]; &#125;&#125; 特例：获取伪元素的样式：getComputedStyle（elem， ‘after’/‘before’)伪元素不能修改样式，但可以通过该class的名，加载不同的样式，达到修改样式的效果。dom操作耗费性能，也可以通过修改类名来批量修改样式值。 脚本化样式表查找，操作样式表：document.styleSheets该属性存储了一个html文档里面的所有css样式表的集合]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>css的脚本化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM操作（十二）]]></title>
    <url>%2F2018%2F08%2F13%2FDOM%E6%93%8D%E4%BD%9C%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DOMDocument Object Model 文档对象模型。定义了表示和修改文档所需要的方法，DOM对象即为宿主对象，有浏览器厂商定义，用来操作HTML和xml功能的一类对象的集合。也有人称之为HTML以及XML的标准编程接口。 DOM的基本操作对节点的增删改查（1）查看元素节点：document代表整个文档document.getElementById() //元素id 在Ie8以下的浏览器，不区分id大小写，而且也返回匹配name属性的元素（name和id混用），选出单个，下面的方法选出的是一个类数组。.getElementsByTagName() // 标签名.getElementsByClassName() // 类名 -&gt; ie8和ie8以下的ie版本中没有，可以多个class一起填括号里进行选择。.getElementByName() //，需注意，只有部分标签name可生效（表单，表单元素，img，iframe）.querySelector() //（关键词条）括号中填 css选择器 在ie7和ie7以下的版本中没有var div = document.querySelector(&#39;.demo&gt;#only&gt;.test&#39;);.querySelectorAll() // css选择器 在ie7和ie7以下的版本中没有，选出满足条件的所有的节点，选出一个类数组。后两种方法选出的节点是非实时的，即后面删除节点时，选出的不受影响。所以不常用。前三个比较常用，后三个了解。（2）遍历节点数parentNode ==&gt; 父节点 (最顶端的parentNode为#document);childNodes ==&gt; 子节点们（文本节点，属性节点，元素节点，注释节点，等都算）firstChild ==&gt; 第一个子节点lastChild ==&gt; 最后一个子节点nextSibling ==&gt; 后一个兄弟元素previousSibling ==&gt;前一个兄弟元素节点的类型：元素节点 —— 1 属性节点 —— 2 文本节点 —— 3 注释节点 —— 8 document —— 9DocumentFragment —— 11获取节点类型 nodeType节点的四个属性：nodeName：元素的标签名，以大写的形式表示，只读。注释节点（#comment），文本节点（#text）。nodeValue：节点的内容，只有text节点和comment节点的文本内容可以进行操作。nodeType：该节点的类型，上面有描述，找type值返回对应的数字。属性节点是标签上的属性，能赋值改动。attributes：Element节点的属性集合。节点的一个方法：Node.hasChildNodes(); 看元素节点node上有无子节点。返回布尔值。（3）基于元素节点树的遍历：parentElement ==&gt;返回当前元素的父元素节点 (IE不兼容)以下IE浏览器指的是IE9以下children ==&gt;只返回当前元素的元素子节点node.childElementCount === node.children.length当前元素节点的子元素节点个数(IE不兼容)firstElementChild ==&gt;返回的是第一个元素节点(IE不兼容)lastElementChild ==&gt;返回的是最后一个元素节点(IE不兼容)nextElementSibling / previousElementSibling ==&gt;返回后一个/前一个兄弟元素节点（IE不兼容) （4）增加节点：①document.createElement();括号里填写‘div’。创建div的元素节点。②document.createTextNode();创建文本节点。③document.createComment();创建注释节点。④document.createDocumentFragment();创建文档碎片节点。 （5）插入节点：①PARENTNODE.appendChild();加在父级节点的最后面。当原本就有的节点，选中之后调用此方法，能改变节点的位置，将其剪切到parentnode的最后面。②PARENTNODE.insertBefore(a, b)。insert a before b 在b的前面插入a。当原有节点，选中之后调用此方法，能改变节点的位置。 （6）删除节点：①parent.removeChild();剪切节点，返回括号中的节点，能接收进而操作。②child.remove(); 子节点的自我删除。哪个调用，哪个自我删除。 （7）替换节点：parent.replaceChild(newNode, originNode);将parent中的originNode替换成newNode。 js性能优化与创建文档碎片在浏览器中，我们一旦把节点添加到document.body（或者其他节点）中，页面就会更新并反映出这个变化，对于少量的更新，一条条循环插入也会运行很好，也是我们常用的方法。代码如下：123456for(var i=0;i&lt;5;i++)&#123; var op = document.createElement(&quot;span&quot;); var oText = document.createTextNode(i); op.appendChild(oText); document.body.appendChild(op); &#125; 但是，如果当我们要向document中添加大量数据时(比如1w条)，如果像上面的代码一样，逐条添加节点，这个过程就可能会十分缓慢。当然,你也可以建个新的节点,比如说div,先将oP添加到div上,然后再将div添加到body中.但这样要在body中多添加一个&lt;div&gt;&lt;/div&gt;.但文档碎片不会产生这种节点.12345678var oDiv = document.createElement(&quot;div&quot;); for(var i=0;i&lt;10000;i++)&#123; var op = document.createElement(&quot;span&quot;); var oText = document.createTextNode(i); op.appendChild(oText); oDiv.appendChild(op); &#125; document.body.appendChild(oDiv); 为了解决这个问题，我们可以引入createDocumentFragment()方法，它的作用是创建一个文档碎片，把要插入的新节点先附加在它上面，然后再一次性添加到document中。代码如下：123456789101112//先创建文档碎片var oFragmeng = document.createDocumentFragment(); for(var i=0;i&lt;10000;i++)&#123; var op = document.createElement(&quot;span&quot;); var oText = document.createTextNode(i); op.appendChild(oText); //先附加在文档碎片中 oFragmeng.appendChild(op); &#125; //最后一次性添加到document中document.body.appendChild(oFragmeng); 经过测试，在ie，firefox下性能明显得以提高。大家可以自己测试下。前端性能优化都是从一些细节地方做起的，如果不加以注意，后果很严重。 DOM结构树（1）Node下有Document，CharacterDate，Element，及Attr（2）Document下有HTMLDocument（3）CharacterDate下有Text和comment（4）Element下有HTMLElement（5）HTMLElement下有HTMLHeadElement，HTMLBodyElement，HTMLTitleElement，HTMLParagraphElement，HTMLInputElement，HTMLTableElement等等。JavaScript选出来的节点就是对象。 DOM基本方法定义的位置：（1）getElementById方法定义在Document.prototype上，即Element节点上不能使用。eg：ul.getElementById();此方法不能用。（2）getElementsByName方法定义在HTMLDocument.prototype上，即非html中的document以外不能使用(xml document,Element)（3）getElementsByTagName方法定义在Document.prototype 和 Element.prototype上eg ：var ul = document.getElementByTagName(“ul”); var li = ul.getElementByTagName(“li”);可行（4）HTMLDocument.prototype定义了一些常用的属性，body,head,分别指代HTML文档中的&lt;body&gt;&lt;head&gt;标签。document.body ==&gt; body标签。（5）Document.prototype上定义了documentElement属性，指代文档的根元素，在HTML文档中，他总是指代&lt;html&gt;元素。document.documentElement ==&gt; html标签。（6）getElementsByClassName、querySelectorAll、querySelector在Document,Element类中均有定义 Element（元素）节点的一些属性和方法属性（1）innerHTML：可读可写Object.innerHTML = “HTML”;//设置，可以直接在页面中加dom结构。var html = Object.innerHTML;//获取，返回的是字符串（2）innerText(火狐不兼容) / textContent(老版本IE不好使)。返回文本，假如赋值的话，会将所有的以前的节点进行覆盖。 方法（1）ele.setAttribute();在元素节点上添加行间属性格式：div.setAttribute(‘class’,’demo’);有class相当于改变class的属性值，没有class，则相当于赋值。（2）ele.getAttribute();格式：div.getAttribute(‘class’); 取出class属性的值。可以通过class的属性值，改css的样式。行间自定义的属性没有意义，但更容易区分元素，用于存数据用，然后取出来与后端进行数据的交互。 查看滚动条的滚动距离window.pageXOffset/pageYOffset ： IE8及IE8以下不兼容（一般的w3c标准的方法，IE9以下不兼容）document.body.scrollLeft/scrollTop；document.documentElement.scrollLeft/scrollTop兼容性比较混乱，有的IE能用前面的，后面的方法返回零；有的IE能用后面的，前面的方法返回零；所以用的时候取两个值相加，因为不可能存在两个同时有值。以下是兼容所有浏览器的获取滚动条距离的函数：12345678910111213function getScrollOffset() &#123; if(window.pageXOffset) &#123; return &#123; X : window.pageXOffset, y : window.pageYOffset &#125; &#125;else&#123; return &#123; X : document.body.scrollLeft + document.documentElement.scrollLeft, y : document.body.scrollTop + document.documentElement.ScrollTop &#125; &#125;&#125; 查看可视区窗口尺寸window.innerWidth/innerHeight ： IE8及IE8以下不兼容document.documentElement.clientWidth/clientHeight：标准模式下，任意浏览器都兼容document.body.clientWidth/clientHeight：适用于怪异模式下的浏览器（向后兼容，新的浏览器能兼容老方法）document.compatMode；调用此方法判断浏览器的模式；返回CSS1Compat则为标准模式；返回BackCompatible则为怪异模式（混杂模式）兼容性写法：123456789101112131415161718function getViewportOffset() &#123; if(window.innerWidth) &#123; return &#123; w : window.innerWidth, h : windwo.innerHeight &#125; &#125;else if(document.compatMode == &quot;BackCompat&quot;) &#123; return &#123; w : document.body.clientWidth, h : document.body.clientHeight &#125; &#125;else&#123; return &#123; w : document.documentElement.clientWidth, h : document.documentElement.clientHeight &#125; &#125;&#125; 查看元素的几何尺寸dom.getBoundingClientRect(); 兼容性很好该方法返回一个对象，对象里面有left,top,right,bottom等属性。left和top代表该元素左上角的X和Y坐标，right和bottom代表元素右下角的X和Y坐标。height和width属性老版本IE并未实现。返回的结果并不是“实时的”。（用处不大） 查看元素（1）查看元素的尺寸：dom.offsetWidth，dom.offsetHeight（2）查看元素的位置：dom.offsetLeft, dom.offsetTop。对于无定位父级的元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的左边线的距离/上边线的距离。（3）获取最近的有定位的父级：dom.offsetParent。返回最近的有定位的父级，如无，返回body, body.offsetParent 返回null 滚动条滚动window上的三个方法：scroll（）；scrollTo（）；这两种方法实现的效果一样，括号中填写x，y的坐标点，将滚动条定位到该坐标点。scrollBy（）；括号中填写x，y的坐标值，但是是坐标的累加值，相当于移动了多少。以下代码相当于一个自动阅读功能，其中三个button标签，给样式，选中分别为start，stop，speed up，`var timer = 0;var key = true;var speed = 1;start.onclick = function() { if(key) { timer = setInterval(function() { window.scrollBy(0,speed); },50); key = !key; }}stop.onclick = function() { clearInterval(timer); key = true;}su.onclick = function() { if(speed &lt; 5) { speed ++; }}]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序报错及es5的严格模式（十一）]]></title>
    <url>%2F2018%2F08%2F13%2F%E7%A8%8B%E5%BA%8F%E6%8A%A5%E9%94%99%E5%8F%8Aes5%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[三目运算符形式：判断语句? (判断若为真，执行，并返回结果) ：(若为假，执行，并返回结果)三目运算符其实就是简化版的if(){…}else{}语句var test = typeof(typeof(undefined))==&quot;undefined&quot;?(NaN == NaN ? 0 : 1) : !!false;先判断括号中的，NaN不等于NaN，所以，括号中为1，因为typeof(undefined)= “undefined”,typeof(“undefined”)= “string”;则执行!!false,则test的结果为false。 逗号运算符不常用。例如：1,2；返回2，返回逗号后面的内容。typeof(new Array).__proto__.constructor();typeof后执行，先执行括号中的new Array,值为[],他的原型上的构造器为Array，typeof一个空数组，结果为”object”。 try … catch12345678910try&#123; console.log(&quot;a&quot;); console.log(&quot;b&quot;); console.log(c); console.log(&quot;d&quot;);&#125;catch(e) &#123; console.log(e.name); console.log(e.message);&#125;console.log(&quot;d&quot;); 打印的结果为a,b,ReferenceError,c is not defined,d。此方法的作用是当try里的语句出现问题时，阻止try里出错的语句后的代码，不会阻止catch后的语句运行，并且将错误的信息（只能是第一个错误）作为兑现返回catch里，e只有name和message的属性值，低级错误无法用try…catch,因为通篇解析时就会报错，整个程序都无法执行。try{}catch(e) {}finally{}finally后无论前面的出错与否，都会执行，所以意义不大。 各种错误类型：（1）EvalError：eval()的使用与定义不一致（2）RangeError：数值越界（3）ReferenceError：非法或不能识别的引用数值（没有定义就使用）（4）SyntaxError：发生语法解析错误 （低级错误，逗号分号之类的）（5）TypeError：操作数类型错误（6）URIError：URI处理函数使用不当 5，es5严格模式：（1）启用es5严格模式，不再兼容es3的一些不规则语法，使用es5的新的规范。（2）两种用法： ①全局严格模式：逻辑的第一行写“use strict”。 ②局部函数内严格模式（推荐）：函数内部的第一行写“use strict”.就是一行字符串，不会对不兼容严格模式的浏览器产生影响。（3）不支持with,arguments.callee,func.caller,变量赋值前必须声明，局部this必须被赋值(Person.call(null/undefined) call的内容就是赋的值，赋值什么就是什么),拒绝重复属性和参数 with：改变作用域链，在作用域顶端加东西。1234567891011var obj = &#123; name : &quot;abc&quot;&#125;var name = &quot;bcd&quot;;function test() &#123; var name = &quot;cde&quot;; with(obj) &#123; console.log(name); &#125;&#125;test();//此时的test执行的结果是在obj上找name的值 with(document) {write(&quot;abc&quot;)};//相当于在document对象上找write方法，打印abc]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>报错及严格模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组（十）]]></title>
    <url>%2F2018%2F08%2F12%2F%E6%95%B0%E7%BB%84%EF%BC%88%E5%8D%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[数组的定义（1）var arr = [ ];数组字面量（基本上用这个函数定义数组）；（2）var arr = new Array（）；构造函数构造数组，当里边儿有多个参数时，参数作为数组的值，当里边儿只填一个数时，则系统默认为arr.length; 数组的读和写（1）arr[num] //不可以溢出读，数组是特殊的对象，当溢出读时，返回undefined；（2）arr[num] = xxx;//可以溢出写，没有写的位置用undefined填充。 数组的常用方法可以改变原数组（1）arr.push();往arr数组里加参数。以下是push方法的代码:1234567891011121314151617181920Array.prototype.push = function() &#123; for(var i = 0; i &lt; arguments.length; i ++) &#123; this[this.length] = arguments[i]; &#125;&#125;（2）arr.pop()：将数组的最后一位删掉，一次只能移除一位，传参数没有作用。实际上是将数组的最后一位剪切出来，用变量能接收数组pop后的值。为数组最后一位。（3）shift()：在数组的前面剪切数组里的参数。（4）unshift()：在数组的最前面加上括号中的参数。（5）splice()：传多位参数，第一个参数代表从第几位开始，第二个参数代表剪切多少个长度，将第三个及以后的参数从切口处添加进去。剪切的参数以数组形式返回。arr.splice(2,0,,,)，从第二位开始切，切零位，常用此方法往数组特定位置加参数。（6）sort()：按阿斯特码进行升序排列（将数字，拆开一位一位比较eg：1&gt;12&gt;2）。可以自己定义使用：①当返回值为负值，那么前面的参数代表的数据就在前面。②当返回值为正值，那么前面的参数代表的数据就在后面。将数组里的数组按升序排列。（返回负值，a，b位置不变）` arr.sort(function(a,b) &#123;return a-b;&#125;); `将数组里的数按降序排列。（返回正值，a，b调换位置）` arr.sort(function(a,b) &#123;return b-a;&#125;); `将数组里的参数乱序排列` arr.sort(function () &#123;return Math.random() - 0.5;&#125;);将name的属性值，按字母从前到后排列 var arr = [ {name : “a”,age : 1}, {name : “b”,age : 2}, {name : “c”,age : 3}, {name : “d”,age : 4}]arr.sort(function(a,b){ if(a.name &gt; b.name) { return 1; }else{ return -1; }})（7）reverse():将数组里的参数逆转。 不可改变原数组的方法：（1）concat()：A.concat(B),将B数组拼接到A数组的后面，然后返回。（2）toString()：将数组变成字符串的形式。（3）slice()：不传参数或者传零，返回原数组；传一个参数slice(2)，截取数组第二位及其以后的值（2前加负号，则倒数第二位）；传两位参数，slice(1,3)，从第一位开始，向后截取三位返回。（4）join()：将数组以什么进行连接，返回字符串。arr.join(“,”),将数组的每一位按逗号进行连接。（默认值）。互逆的方法：split()，将字符串按括号中的字符拆分成数组。用空拆，则会单个字符作为数组的一位。 MathMath是定义的空函数，保存了很多的方法。不用new构造Math对象，这种方法叫静态方法。（静态类）123function Math()&#123;&#125;Math.random = function() &#123;&#125;Math.floor = function() &#123;&#125; 类数组（1）可以利用属性名模拟数组的特性（2）可以动态的增长length属性（3）如果强行让类数组调用push方法，则会根据length属性值的位置进行属性的扩充。1234Array.prototype.push = function(target) &#123; this[this.length] = target; this.length ++;&#125; 假如类数组没有length值，默认为零。以下代码执行两次，最后的结果是length为5.123456789var obj = &#123; &quot;2&quot; : &quot;a&quot;, &quot;3&quot; : &quot;b&quot;, length : 3, push : Array.prototype.push&#125;obj.push(&quot;c&quot;);obj.push(&quot;d&quot;);//此时访问obj为： Object&#123;2: &quot;a&quot;,3:&quot;c&quot;,4:&quot;d&quot;,length: 5&#125; 如何将类数组转化成数组：在类数组里定义slice方法，slice：Array.prototype.slice然后用类数组调用slice方法，空截取，就能将类数组转化成数组。 数组去重利用对象的属性名不可重复来进行去重，代码入下Array.prototype.unique = function() { var obj = {}, len = this.length, arr = []; for(var i = 0; i &lt; len; i ++) { if(!obj[this[i]]) { obj[this[i]] = 1; arr.push(this[i]); } } return arr;}`obj[this[i]] = 1中的1可以为任何属性值，但不能为this[i],此时无法去除undefined，0，false，NaN的重复。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的继承及枚举（九）]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%A7%E6%89%BF%E5%8F%8A%E6%9E%9A%E4%B8%BE%EF%BC%88%E4%B9%9D%EF%BC%89%2F</url>
    <content type="text"><![CDATA[继承（1）传统形式 ==&gt; 原型链（最初的继承）弊端：过多继承了没用的属性。（2）借用构造函数弊端：不能继承借用构造函数的原型，且每次构造函数都要多走一个函数（3）共享原型弊端：不能随便改变自己的原型 以下代码：1234567function inherit(origin,target) &#123; target.prototype = origin.prototype;&#125;Person.prototype.lastName = &quot;Mero&quot;;function Person() &#123;&#125;function son() &#123;&#125;inherit(Person, son); 当new Son()；的对象上有一个原型，原型上有一个lastName的属性，new Person也有一个共同的原型，这种方法用了很长以段时间。但当用Son.prototype添加属性时，new Person构造对象时，也会有添加的属性，无法实现个性化。 12345678Person.prototype.lastName = &quot;Mero&quot;;function Person() &#123;&#125;F.prototype = Person.prototype;function F () &#123;&#125;var f = new F();PersonAnother.prototype = f;PersonAnother.prototype.age = 123;function PersonAnother() &#123;&#125; 通过中间函数F，new出来的f是一个空对象。F和Person共用一个原型，PersonAnother由F处继承原型（向上访问原型到Person的原型），可实现单个改动不影响另外一个。继而发展出了以下的圣杯模式。1234567891011121314151617function inherit(origin, target) &#123; function F () &#123;&#125;; F.prototype = origin.prototype; target.prototype = new F(); target.prototype.constructor = target; target.prototype.uber = origin.prototype;&#125;//以下是另一种雅虎库里的写法var inherit = (function ()&#123; var F = function () &#123;&#125;; return function (origin.target) &#123; F.prototype = origin.prototype; target.prototype = new F(); target.prototype.constructor = target; target.prototype.uber = origin.prototype; &#125;&#125;()) 命名空间管理变量，防止污染全局变量，适用于模块儿化开发（多个人编码时变量相同导致的系统崩溃）以下以一个实现两个数相加的方法来介绍一种解决全局变量污染的方法123456789101112var add = (function()&#123; var count1 = 0; var count2 = 0; function myAdd(num1, num2) &#123; count1 = num1; count2 = num2; console.log(count1 + count2); &#125; return function (num1,num2) &#123; myAdd(num1, num2) &#125;;&#125;()) 对象属性的访问方式：（1）obj.name，以此方式访问属性，系统内部转换成obj[‘name’]形式。（2）obj[‘name’],可以灵活的拼接继而访问属性123456789function getProp(num) &#123; var obj = &#123; a1 : 123; a2 : 234; a3 : 345; &#125; console.log(&quot;a&quot;+ num);&#125;getProp(2);//找到的是a2的值234； person.prototype的指向问题12345678Person.prototype = &#123; name: &quot;sunny&quot;&#125;function Person() &#123;&#125;var person = new Person();Person.prototype = &#123; name : &quot;cherry&quot;&#125; 当用person.prototype.name = cherry；时，person.prototype指向的是原有的房间，此时会改变sunny为cherry，但是当用person.prototype = {name :”cherry”},改变了指向的房间，原有的sunny不受影响 对象属性的遍历12345678var obj = &#123; name : &quot;abc&quot;, age : 123, sex : &quot;female&quot;&#125;for(var prop in obj) &#123; console.log(obj[prop]);&#125; 每次循环时，打印的prop为obj的属性名。是字符串的格式。不能用obj.prop,系统内部会转成obj[“prop”];即为查找obj里有无prop属性。for in循环专注于遍历对象里的属性。但for in 循环有以下弊端：用构造函数构造对象时，会遍历自己定义的原型上的属性，但不会吧Object.prototype遍历出来。hasOwnProperty()；判断括号中的属性是否是其自身的属性，是返回true，不是返回false。用来过滤原型链上的属性。var obj = {} console.log(&quot;name&quot; in obj)in方法，看属性在某个对象中能否找到，返回布尔值，但原型链上的属性也能被找到，返回true。instanceof：A instanceof B 看A是否是由B的构造函数构造而来，返回布尔值。但原型链上的构造函数也算。所以instanceof的作用是判断A的原型链上有无B的原型。 arguments：函数里面的类数组，存的是实参arguments.callee：指向的是函数的本身，相当于函数名。123456var num = (function(n) &#123; if(n == 1) &#123; return 1; &#125; return n * arguments.callee(n-1);&#125;(5)) 形如上述的立即执行函数，没有函数名，但要算5的阶乘，则return n * 函数名（n - 1），而立即执行函数没有函数名，则用arguments.callee来代函数的引用。caller：当前函数所被调用的环境的函数。1234567function demo () &#123; text();&#125;function text() &#123; console.log(text.caller) &#125;text(); 当函数demo执行时调用text，此时text执行的环境就是demo函数，text.caller 就是函数demo，当text函数自执行时，text就没有执行环境，此时text.caller 就是null。 对象的深度克隆12345678910111213141516171819202122232425262728293031323334353637function deepClone(origin, target) &#123; var target = target || &#123;&#125;, arrStr = &apos;array-Object&apos;; for(var prop in origin) &#123; if(typeof(origin[prop]) == &quot;object&quot;) &#123; if(type(origin[prop]) == arrStr) &#123;//type函数用于判断数据类型 target[prop] = []; &#125;else&#123; target[prop] = &#123;&#125;; &#125; deepClone(origin[prop],target[prop]); &#125;else&#123; target[prop] = origin[prop]; &#125; &#125;&#125;function type(target) &#123; var typeStr = typeof(target); var toStr = Object.prototype.toString; var objStr = &#123; &quot;[object Object]&quot; : &quot;object - Object&quot;, &quot;[object Array]&quot; : &quot;array - Object&quot;, &quot;[object Number]&quot; : &quot;number - Object&quot;, &quot;[object Boolean]&quot; : &quot;boolean - Object&quot;, &quot;[object String]&quot; : &quot;string - Object&quot; &#125; if(target === null) &#123; return null;//判断target是否是null &#125;else if(typeStr === &quot;function&quot;)&#123; return &quot;function&quot;;//判断是否是函数类型 &#125; if(typeStr !== &quot;object&quot;)&#123; return typeStr;//判断原始值 &#125;else&#123; return objStr[toStr.call(target)];//判断引用值 &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this指向及call，apply（八）]]></title>
    <url>%2F2018%2F08%2F12%2Fthis%E6%8C%87%E5%90%91%E5%8F%8Acall%EF%BC%8Capply%EF%BC%88%E5%85%AB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[this：（1）函数预编译过程中：this ==&gt;window;（2）全局作用域里：this ==&gt; window;（3）call和apply可以改变函数运行时this指向。（4）obj.function();对象里的方法中的函数的this指向obj。12345678var obj = &#123; age = 123, smoke : function () &#123; console.log(this); &#125;&#125;var smoke1 = obj.smoke;smoke1(); obj的smoke方法体给了smoke1，则此时走的预编译环节，打印的this是window。 12345678910111213141516171819var name = &quot;222&quot;;var a = &#123; name : &quot;111&quot;, say : function () &#123; console.log(this.name); &#125;&#125;var fun = a.say;fun();//222,因为a的say方法体给了fun，走函数预编译，this指向windowa.say();//函数执行时的this指向a对象，则打印111var b = &#123; name : &quot;333&quot;, say : function (fun) &#123; fun(); &#125;&#125;b.say(a.say);//222,将a.say的方法体拿出来在b.say当中执行，fun空执行，走预编译，指向windowb.say = a.say;b.say();//333,b.say的this指向的b对象 call：函数执行时的this指向问题当函数执行时，person()和person.call()完全等价，当函数执行时，系统也会隐式的换成person.call()123456function Person(name, age) &#123; this.name = name; this.age = age;&#125;var obj = &#123;&#125;;Person.call(obj,&quot;Mero&quot;,123); person.call()括号中的传参，第一位参数将person中的this指向obj对象（类似于obj替换person里面的this）第二位参数为第一位形参对应的形参，以此类推。 apply：函数执行时的this指向问题和call的作用相同，区别在于传参的形式不一样。例如以上代码的传参用apply表示为person.apply(obj,[&#39;Mero&#39;,123]); 第一位参数为this的指向，第二位及以后代表形参对应的实参，需要用[]包裹，数组的形式。开发过程中apply用的比较多，原因是：123456789function Person(name, age)&#123; this.name = name; this.age = age; &#125;var obj = &#123;&#125;;function test()&#123; Person.apply(obj,arguments);&#125;test(&apos;Mero&apos;,123);//用person操作obj，test传参，但没有形参，此时用apply，直接将实参列表arguments传入。 call和apply的使用1234567891011121314function PublicPerson(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; //this.xxx = (function()&#123; // 这是一个非常复杂的操作 //&#125;())&#125;function Person(name, age, sex, aihao) &#123; //var this = Object.create(Person.prototype); PublicPerson.call(this, name, age, sex); this.aihao = aihao;&#125;var person = new Person(&apos;xiaozhang&apos;,123,&apos;female&apos;,&apos;undefined&apos;); person里想有publicperson里的属性，用call，传的第一个this是person里的this，将publicperson里的this进行替换，使得相似的公有属性能够用别人的。个性化的东西自己传。注意：bind也能改变this的指向，但是当用bind改变this指向之后，无法在次进行改变。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的原型（七）]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%EF%BC%88%E4%B8%83%EF%BC%89%2F</url>
    <content type="text"><![CDATA[原型的定义原型是function对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。 理解（1）即为函数定义之后：function Person(){ },其自带了一个属性，person.prototype = { constructor : Person;}(相当于空对象）constructor构造器。Person.prototype.name = “Mero”；var person1= new Person();此时，person1仍然是一个空对象，但访问person1.name有值为Mero。拿的是构造器的name值。相当于父级的name属性值。通过原型增加属性，通过构造函数的方法，构造对象，能继承原型的属性（原型作为公有祖先）例如以下代码：1234567Person.prototype.name = &quot;mero&quot;;Person.prototype.age = 20;function Person () &#123;&#125;var person1 = new Person();var person2 = new Person(); 两次new构造的两个对象，都继承原型的值，即访问person1.name和person2.name的值一样 原型上的查找在原型上的属性和方法只能查，无法进行改和删。但是不绝对，某种情况下能改12345678Person.prototype.card = [100,100,200];funtion Peroson()&#123;&#125;var person1 = new Person();var person2 = new Person();person1.card //[100,100,200]person1.card.push(100);person1.card //[100,100,200,100];//此时是调用card数组自己的方法给自己添加值，能够修改（调用引用值的方法修改自己） 原型的用法提取公有属性，将耦合（需要反复执行的代码叫耦合）代码放到原型里面去。原型只执行一次，可以将非个性化的属性放入原型中，避免每次构造对象时重复执行某段代码123456789Car.prototype = &#123; height : 199, width : 100&#125;function Car(color) &#123; this.color = color;&#125;var car1 = new Car(&apos;green&apos;);var car2 = new Car(&apos;red&apos;); 构造函数本身有一个prototype属性，值是一个空对象，以上的给原型上添加属性的方法是将原有的空对象进行替换，而用car.prototype.height = 199;是通过原有的对象上添加自己的属性，两种方法不一样。 对象如何查看原型构造函数new之后产生的this对象，有一个proto属性（隐式属性），值为obj.prototype;访问属性时，先找自己的属性，没有，再访问原型上的属性。 如何查看对象的构造函数constructor构造器；即对象由哪个函数构造而来。每个对象都有一个constructor属性，其值为它的构造函数。直接以对象字面量构造对象：var obj = { };他会有一个proto属性，值为function Object(){ };直接给出一个对象，Car.prototype = { };内部无constructor，只能由原型链向上查找，查找object.prototype上的constructor，值为function object(){ }；手动在Car.prototype = {constroctor:Car};手动设置构造函数。但凡是对象，都有其原型，Object.prototype 为终点，其无proto属性。 原型链（1）构成原型链123456789101112131415GrandFoo.prototype.lastName = &quot;ji&quot;;function GrandFoo() &#123;&#125;var grandFoo = new GrandFoo();Foo.prototype = grandFoo;function Foo() &#123; this.money = 100;&#125;var foo = new Foo();Son.prototype = foo;function Son() &#123; this.age = 18;&#125;var son = new Son();son.abc = &apos;abc&apos;;son.money = &apos;200&apos;; 设置构造函数的prototype为其原型的对象，而GrandFoo.prototype.lastName是在GrandFoo的原型上添加属性。原型链上的属性只能查（属性赋值无法改变，除非调用引用值自己的方法改变）。访问时由下往上访问，终点是Object.prototype。（2）var obj = Object.create(Object.prototype);括号中填原型，则构造出一个对象，和new Object 如出一辙。12345var a = &#123; name : &quot;abc&quot;, age : 123&#125;var obj = Object.create(a); 括号中填写了一个a对象，此方法括号中可以直接填一个对象，充当obj对象的原型，当填原始值时，报错，非对象的值都报错，null除外；var obj = Object.create(null);没有父级原型。此时访问obj，显示的是：Object{ No Properties}但仍然可以添加属性，无法通过原型链访问不属于他的属性，无proto属性。属于无原型对象。当使用document.write(object);打印对象时，隐式执行object.toString();方法，如果该对象没有toString方法，访问原型上的toString，返回[object Object]; 采用create（null）的方法构造对象时，无toString方法，无原型链，所以无法调用toString，此时报错。绝大多数对象的最终都会继承自Object.prototype，但并不是所有，除Object.create(null);无原型。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象及包装类]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对象的定义对象是JavaScript的一个基本数据类型，是一种复合值，它将很多值（原始值或者其他对象）聚合在一起，可通过名字访问这些值。即属性的无序集合。 对象的增，删，改，查（1）查：属性的查看：mrDeng.firsrName; mrDeng.age;方法的查看与执行：mrDeng.smoke;查看 mrDeng.smoke();执行；（2）改：采用变量的赋值改变。原始值和引用值都能改：mrDeng.wife = {修改后的引用值}；（3）增：对象名.对象的属性或方法（想添加的） = 想添加的属性值或方法体。（4）删：delete mrDeng.drink;删除drink方法。无法删除对象，只能删除对象里面的属性和方法。 定义对象的方法（1）var obj = { }; plainObject对象字面量或直接量。（2）系统的构造方法：var obj = new Object();和对象字面量的定义方法绝对等于。按对象的增添加属性和方法。公司开发规范：能用对象直接量，尽量写对象直接量。（3）自定义的构造函数：function Person(){ }; var person = new Person();首字母大写是为了区别构造函数和普通函数。因为两者没有区别。（4）Object.create(原型)方法 构造函数内部原理12345678function Person(name,age,sex) &#123; //var this = &#123;&#125;; this.name = name; this.age = age; this.sex = sex; //return this;&#125;var person = new Person(&quot;lisong&quot;,18,&quot;male&quot;); new之后发生了三步，第一步，隐式的执行var this = {}；第二步，执行函数体内的this.xxx= xxx;最后一步返回this。没有new的时候，相当于就是一个普通函数，此时里面的this指向window。如果显式地return一个原始值时，执行隐式的返回this对象，如果是引用值，则返回的是那个应用值。new之后返回的一定是对象。1234567function Person(name,age) &#123; var that = &#123;&#125;； this.name = name; this.age = age; return [];&#125;var person = new Person(&quot;xiaozhang&quot;,123); 以上的person是一个数组，因为显式的返回数组，当返回that时，则返回的是一个空对象。一个函数只能有一个返回值。 使用自定义构造函数的好处①有相同属性和方法的多个对象可以由一个构造函数构造而来，不同的方法和属性则分开添加。工厂化开发。（相同构造函数构造的对象互不影响）1234567function Car() &#123; this.name = &apos;Maserati&apos;; this.height = 1400; this.width = 2000;&#125;var car = new Car();var car1 = new Car(); ②可以进行传参，根据传参的不同，构造不同的对象。 obj 12345 height : 100, eat : function() &#123; obj.height ++;//先取出obj.height,再执行方法，致力于改变其自身的属性。 &#125;&#125; 包装类（1）给原始值加属性加方法，访问属性，访问方法都是包装类。Number ==&gt; new Number() ==&gt; 数字的对象形式String ==&gt; new String() ==&gt; 字符串的对象形式Boolean ==&gt; new Boolean() ==&gt; 布尔的对象形式（2）原始值不能有属性，形式上能赋值，但是无法存储，隐式执行后被销毁。12345var num = 123;num.abc = &apos;a&apos;;//添加abc属性时，隐式执行new，变为数字的对象形式，执行完即销毁。//new Number(num).abc = &apos;a&apos;;console.log(num.abc);//访问时，再次新new出来的数字的对象形式找不到num.abc.//new Number(num).abc; 12345var str = &apos;abcd&apos;;str.length = 2;//new String(str).length = 2 --&gt;deleteconsole.log(str.length);//new String(str).length; 字符串没有length属性，当给str.length赋值时，隐式new，变为字符串的对象形式，然后将length变为2，但执行完即销毁，并不对字符串进行length的截断处理。当访问str.length时，再一次变为新的字符串的对象形式，将原有的字符串的长度返回。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包（五）]]></title>
    <url>%2F2018%2F08%2F09%2F%E9%97%AD%E5%8C%85%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[产生原因及危害当内部函数别保存到外部时，会产生闭包，闭包会导致原有的作用域链不释放，造成内存泄漏（占有原有的空间，使得原有空间的内存减少，造成内存泄漏的效果） 闭包的作用（1）实现公有变量函数累加器：1234567891011function add() &#123; var num = 0; function demo() &#123; num ++; console.log(num); &#125; return demo;&#125;var test = add();test();test();//调用一次，累加一次，改变的是公有的变量。 （2）调用缓存（浏览网页时图片存储到本地，下次访问时，调用缓存）12345678910111213function test() &#123; var num = 0; function a() &#123; console.log(++num); &#125; function b() &#123; console.log(--num); &#125; return [a,b];&#125;var arr = test();arr[0]();arr[1]();//函数a和函数b作用的是同一个变量，所以作为一个存储机构 （3）实现封装，属性私有化12345678910111213141516171819202122232425function wu() &#123; var prepareWife = &quot;xiaozhang&quot;; var obj = &#123; name : &quot;wuqi&quot;, age : 18, sex : &quot;male&quot;, wife : &quot;xiaodai&quot;, divorce : function() &#123; delete this.wife; &#125;, getMarried : function() &#123; this.wife = prepareWife; &#125;, changePrepare : function(someone) &#123; prepareWife = someone; &#125;, sayMyWife : function() &#123; return this.wife; &#125; &#125; return obj;&#125;var wu = wu();//以上代码立意稍微有点儿low，但是为了便于记忆，就这么写吧//prepareWife和对象中的方法形成闭包，可以调用对象中的方法进行操作，改变，但是无法从外部进行访问，称为私有化变量。（不能通过外在的任何形式去改变这个变量，只能通过对象留出来的方法和接口去改变这个变量。 （4）模块儿化开发，防止污染全局变量。 闭包的解决方法——立即执行函数（1）此类函数没有声明，在一次执行过后即释放。适合做初始化工作。（2）格式：(function(){})()最后一个括号是执行的代码。（3）立即执行函数和普通函数的区别是执行完就被销毁，再也无法找到。括号中还可以传形参和实参。（4）立即执行函数是后来的人添加上去的作用。只有表达式才能被执行。函数声明不能被执行。①直接写function text(){}() 后面的括号没有执行函数的功能，会报错。②var a = function(){}() 函数表达式声明的函数后面的括号有调用函数执行的功能，表达式执行完后，就会被销毁。此时再找函数a，无法找到。所以这也是种立即执行函数。③函数声明前加正负号，可以将函数声明变为表达式，此时，函数声明后可以加括号，使函数立即执行。（！也有相同的作用）综上所述：函数声明外加括号，将函数声明变为表达式，后加括号，函数执行，表达式执行完后，会被销毁。所以称为立即执行函数。(w3c的标准立即执行函数：(function(){}()) )特例：function text(a,b){ console.log(a,b);}(1,2);虽然不是表达式，不能执行，但也不会报错。系统会将（1,2）不认为为函数的执行，而是将其看成为一个式子。（该式子的作用是：var text = (1,2),text就是逗号的后面那位2。返回后面的数） 闭包的危害闭包会导致多个执行函数共用一个公有变量，如果不是特殊需要，应尽量避免这种情况发生。12345678910111213function text() &#123; var arr= []; for(var i = 0;i &lt; 10; i++) &#123; arr[i] = function () &#123; document.write(i + &quot; ,&quot;); &#125; &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt;10; j++) &#123; demo[j]();&#125; text函数里面有var i；for循环将i的值已经加到10，当函数执行时，找的实际上是最后的10，所以打印10个10，解决方法是：123456789101112131415function text() &#123; var arr = []; for(var i = 0; i &lt; 10; i++)&#123; (function(j) &#123; arr(j) = function() &#123; console.log(j); &#125; &#125;(i)) &#125; return arr;&#125;var demo = text();for(var j = 0; j &lt;10; j++) &#123; demo[j]();&#125; 将 i 作为实参传入函数时，相当于在立即执行函数内var j ；j 的值根据for循环分别为0~9；那么相当于返回的函数是：var j = 0~9；function () { console.log(j);} 小练习123456789101112131415161718192021a = 100;function demo(e) &#123; function e() &#123;&#125; arguments[0] = 2; document.write(e); if(a) &#123; var b = 123; function c()&#123;&#125; &#125; var c; a = 10; var a; document.write(b); f = 123; document.write(c); document.write(a);&#125;var a;demo(1);document.write(a);document.write(f); 以上代码的打印结果为：2 undefined undefined 10 100 123 （if语句里不能定义函数，也就不存在函数提升。f能够访问，是因为没有用var f，此时的f的作用域是全局。） （2）(window.foo ||(window.foo = “bar”));输出的window.foo的值为bar，因为先执行括号里面的，先给foo赋值bar，再进行判断，则foo为bar。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数（四）]]></title>
    <url>%2F2018%2F08%2F09%2F%E5%87%BD%E6%95%B0%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[函数定义（1）函数声明：function text(){};括号中可以加形参，执行时，text()；括号中传实参。函数名或者变量名由多个单词拼接，必须满足小驼峰式写法：首个单词首字母小写，其他单词首字母大写。（2）函数表达式：var text = function text(){}；执行时，以变量名加括号执行，括号中可以传值。表达式中的函数名忽略，无作用。有text.name 方法，name值为function后面的text。匿名表达式：var text = function(){};name值为定义的变量名。 函数的组成形式（1）函数名称：function后面的就是函数名称，当用函数表达式定义函数时，名称为定义的变量名（2）参数：形参和实参。①形参一般在函数的定义的括号中传，实参是函数执行时传递到函数体内，替换形参，再执行函数的参数。②实参和形参的位数不一定需要相同。函数代码内：隐式有一个arguments是一个数组，将实参存储到arguments。数组的length值与传入的实参位数相同，函数体内能找到arguments。③function text(){}，在函数体内找text.length值，（形参里也有length属性）则为形参的位数。（3）返回值：终止函数和返回值（用变量接收返回值，方便后续的应用）。 典型的函数计算递归函数：123456function mul(n)&#123; if(n == 1)&#123; return 1; &#125; return n *mul(n-1); &#125;//计算n的阶层 递归的好处：便于编程和思考。坏处：效率极其底。 JavaScript运行三部曲：（1）语法分析：通篇扫描，看有无语法错误。（2）预编译：以下详细介绍。（3）解释执行：按语句顺序一步步执行。 函数预编译（1）imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值（变量不能未经声明就使用），此变量就为全局对象所有。eg: a = 123;不报错。全局的变量a和window.a等价。 eg: var a = b = 123;此赋值的顺序是b = 123;var a;a = b;在函数体内，a是局部变量，全局无法访问，而b属于未经声明就赋值，变量归window所有，全局可以访问。（2）一切声明的全局变量，全是window的属性。eg:var a = 123; ===&gt; window.a = 123;（3）变量声明提升：相当于把变量声明语句提升到程序最前。在var a = 123;之前找a的值，有声明，无赋值，结果为undefined。相当于把var a;提升到最前。（4）函数声明整体提升：相当于把函数声明提升到最前。在函数声明之前查找函数名，能找到函数。相当于把函数整体提升到最前。（5）预编译四部曲：预编译发生在执行的前一刻。函数的预编译产生一个叫执行期上下文的对象Activation Object（即AO对象）①创建AO对象②找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined。③将实参和形参相统一。④在函数体内找函数声明，值赋予函数体。（6）全局的预编译：创建GO对象（全局的执行期上下文）；找变量声明，将变量声明作为GO的属性名，值为undefined；找函数声明，值赋予函数体。事例：123456789101112glob = 100;function text() &#123; console.log(glob);//打印结果为function glob()&#123;&#125; glob = 200; funtion glob() &#123;&#125; console.log(glob);//200 var glob; console.log(glob);//200&#125;test();var glob;console.log(glob);//100 if条件语句里不能定义任何函数，即不存在函数声明提升。但if语句里的变量声明仍会提升。 作用域精解（1）所有引用值都有属性和方法，有属性和方法的都可以叫做对象（引用值可以叫做对象），JavaScript函数都是一个对象，对象中有些属性我们可以访问，但有些属性不可以，仅仅供JavaScript引擎存取。例如函数的 [[scope]] 属性，存在函数的作用域，无法修改，存储了函数的执行期上下文。（ao的链）（2）作用域链：[[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们把这种链式链接叫做作用域链。（3）执行期上下文：当函数执行前一刻，会创建一个称为执行期上下文的内部对象。一个执行期上下文定义了一个函数的执行时的环境。函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕它所产生的执行期上下文被销毁。每次新执行时会产生一个新的执行期上下文。（4）如下代码：123456789function a()&#123; function b ()&#123; var b = 123; &#125; var a = 123; b(); &#125; var glob = 100; a(); 函数a定义时：a.[[scope]] 指向 scope chain 指向 对象，第一位是全局的GO函数a执行时：a.[[scope]] 指向 scope chain 指向 对象，第一位是函数的局部AO，二是全局GO。函数b定义时：处于a函数的内部，则会拿到a执行时的scope chain指向的对象。即a的AO和GO。函数b执行时：scope chain指向的对象，第一位为b的AO，第二位是a的AO，第三位是全局的GO。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型转化（三）]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[编程形式的区别（1）面向过程：以事件为中心的编程思想。就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。典型的就是：C语言，（2）面向对象：把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。比如：JAVA ，Delphi，C#这些都是，而JavaScript既面向过程又面向对象。 typeof方法（判断数据类型）（1）返回的六个数据类型：number，string，Boolean，undefined，object，function。这六种类型都是字符串的类型（字符串的number，string，Boolean，undefined，object，function）（2）能够准确判断的只有：number，string，Boolean，undefined四种类型，后两种无法准确判断。例如：typeof(null) = object；判断引用值时返回的都是object。（3）typeof();括号中加入传一个未经声明的变量，不报错（唯一 一个），返回undefined。 显式类型转换（1）var num = Number();将字符串转换成数字类型。null转成0，undefined为NaN，空串为0，false为0，true为1。无法转换的字符串为NaN。（2）var num = parseInt();将字符串转换成整数类型，从数字类看到非数字类截止，转为整型返回。null，undefined，false，true转换为NaN。parseInt(“123”,16);16为基底（基底范围为2-36），将括号中的123看成16进制的数，然后转换成十进制的数。0也可以为基底，看成十进制，但有的浏览器用不了。（3）var num = parseFloat();将字符串转换成小数。（4）var num = String();转换成字符串。（5）var num = Boolean();转换成布尔值。（6）var str = ; var num = str.toString();调用toString方法。转换成字符串。null和undefined没有toString方法。括号中传数字，将str看成十进制的数，转换成括号中数字进制的值。 隐式类型转换（1）isNaN();是数字返回false，不是数字返回true。var num = ; var b = isNaN（num）；两段代码之间隐式调用了Number方法，转换成数字类型，在看是否和NaN相等。（NaN不等于任何值）。（2）”++/–” “+/-（一元正负）”；当有加加和减减符号时，会先隐式调用number方法，转成数字类型，不管先运算还是先执行。当+/-作为正负的符号时，调用number方法，转成number类型。（3）”+”①数值类型和布尔类型的相加，将布尔类型的值转为number值，再运算，结果为number类型。②数字和数字相加，运算结果为数字类型。③数字和字符串相加，先将加号两边转换成string类型，再进行拼接，运算结果为string类型。是拼接，而不是运算。（4）”-“, “*”, “/“, “%”；将符号两侧的都变成数字类型，再进行运算，计算的结果是数字类型。（5）”&amp;&amp;”, “||”, “!”；判断之前调用Boolean方法，转成布尔值进行判断。（6）”&lt;” “&gt;”, “&lt;=”, “&gt;=”；当符号一侧为数字时，调用number方法，将另外一个转成数字类型，再进行比较。null和undefined无法和零进行比较，他俩相等。（7）”==”, “!=”；和大于小于的规则一样。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>类型转化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScriptt运算符（二）]]></title>
    <url>%2F2018%2F08%2F09%2FJavaScriptt%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[算术运算符（1）”+”代表数学运算、字符串链接，任何数据类型加字符串都等于字符串“-“,”“,”/“,”%”,”=“,”()”,优先级”=”最弱，”()”优先级较高“++”,”–”,”+=”,”-=”,”/=”,”=”,”%=”（2）js中的算术运算符：除了普通的加，减，乘，除，求余之外，还有以下更为复杂的运算符：12345678910111213141516Math.pow(2,53)//代表2的53次幂Math.round(.6)//括号中的数取四舍五入Math.ceil()//向上求整Math.floor()//向下取整Math.abs()//求绝对值Math.max(,,,,)//返回最大值Math.min(,,,)//返回最小值 Math.random()// 生成一个0到1的随机数Math.PI// 圆周率Math.E// e，自然对数的底数Math.sqrt()//开平方根Math.pow(3,1/3)//3的立方根Math.sin()// 三角函数，还有Math.cos()，Math.tan()Math.log()//求括号中的自然对数Math.log(100)/Math.LN10// 以10为底100的对数 Math.exp()//e的多少次幂 （3）在浏览器中，小数点后面最多展示17位，小数点前可计算范围17位。标准时前十六后十七。a ++：先运算这行语句，再加加（++a：先加加，再运算这行语句）类似还有–a，a–。a +=b：即为a= a+b。不可计算的结果是NaN。（4）交换两个变量的值：1234var a= 123;var b = 234,a= a+b;b = a-b;a = a-b; 比较运算符“&lt;”, “&gt;”, “==”, “&gt;=”, “&lt;=”, “!=” 比较的结果为Boolean值，返回true或者false，比较运算符的左右先运算，再进行比较，undefined与零无法进行比较，返回false。 逻辑运算符：（1）”&amp;&amp;”（与）：a &amp;&amp; b 将a式转换成布尔值看真还是假，为真，则看b的值，返回b的值。当a为假，则直接返回a的值。（第一个转换成布尔值为true看第二个，false看第一个）。var data； data &amp;&amp; function（data）；假如data的值转换为布尔值为false，则不执行后面函数，为true，则后面的语句执行，可作为条件。（2）”||”（或）：a || b 将a式转换成布尔值看真还是假，找到为真的值就返回，如果都没有，则返回最后一个值。（全假才为假，有一个真就是真）。var event = e || window.event；哪个有值取哪个 。（3）”!”（非）：返回true和false，原本的值转换成布尔值取反，再返回。!!a（将a转换成布尔值）（4）转换成布尔值的返回值为false的六个值：undefined，NaN，null，0，””，false。除了这六个值之外的其他值转换成布尔值为true。(值为空，是””,中间没有空格) 条件语句：（1）if(条件){执行语句}else{执行语句}：当条件成立的时候，走第一个代码块儿，当条件不成立的时候，执行else后面的代码块儿。（else if：条件满足之后不继续往下走）if(1&gt;2){ 执行语句 } == 1 &gt; 2 &amp;&amp; 执行语句；var score = parseInt(window.prompt(‘input’));浏览器有输入框，且输入数字。（2），for循环： for（1；2；3）{ 执行语句 }先执行1语句，再判断条件2，如果2成立，执行代码块中的语句。执行3，再判断条件2，成立，执行代码块儿中的语句，执行3，再判断2，如果不成立，结束循环。（当条件2为true时，无限循环）打印100到0的数：var i = 100; for(; i–;){document.write(i);} 当i–为零时，跳出循环。（3）， while 循环：特殊的for循环。12345678var i = 0;var key = true;while(key) &#123; i ++; if(i &gt; 100) &#123; key = !key &#125; &#125; 循环101圈。此时key为for循环中的条件2， i++为语句三， var i = 0为语句1。do while循环：先do，再while循环，无论条件成立与否，先执行一遍，公司很少用。（4）switch case语句：switch（demo）{ case 1：执行语句；case 2：执行语句；}当switch传入的数据，和case后的数据比较，匹配到相同的值时，执行该case后的执行语句。但当匹配到相同的数据时，会执行该case以及该case后所有的case。解决办法：执行语句后加break，结束循环。default：当所有数据都匹配不上时，执行default后的语句。continue：结束本次循环，继续下一循环。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识JavaScript之JavaScript历史（一）]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%88%9D%E8%AF%86JavaScript%E4%B9%8BJavaScript%E5%8E%86%E5%8F%B2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[JavaScript历史1.浏览器发展史：1993年，出现互联网历史上第一个普遍使用和能够显示图片的网页浏览器Mosaic。1994年4月，马克.安德森和Silicon Graphics（简称为SGI，中译为“视算科技”或“硅图”）公司的创始人吉姆·克拉克（Jim Clark）在美国加州设立了“Mosaic Communication Corporation”。Mosaic公司成立后，由于伊利诺伊大学拥有Mosaic的商标权，且伊利诺伊大学已将技术转让给Spy Glass公司，开发团队必须彻底重新撰写浏览器程式码，且浏览器名称更改为Netscape Navigator，公司名字于1994年11月改名为“Netscape Communication Corporation”，此后沿用至今，中译为“网景”。微软的Internet Explorer及Mozilla Firefox等，其早期版本皆以Mosaic为基础而开发。微软随后买下Spy Glass公司的技术开发出Internet Explorer浏览器，而Mozilla Firefox则是网景通讯家开放源代码后所衍生出的版本。 ①浏览器的构成：内核和shell外壳部分，内核包括渲染引擎、js引擎、其他部分②主流浏览器及其内核：IE（Internet Explorer）内核为trident；Safari（苹果搜索）内核为webkit；Google Chrome内核为webkit+blink；Firefox（火狐）内核为Gecko；Opera（欧朋，慢但是兼容性强）内核为presto。③360极速模式下用的webkit内核，正常模式用的webkit加tridentUC浏览器用的webkit，其他中国浏览器大部分用的webkit内核 2.JavaScript历史：1996年，JavaScript作为Netscape Navigator浏览器的一部分首次出现。它最初的设计目标是改善网页的用户体验。JavaScript作者：Brendan Eich （Java之父：比尔乔伊）起初JavaScript被命名为，LiveScript，后因和Sun公司合作，因市场宣传需要改名JavaScript。后来Sun公司被Oracle收购，JavaScript版权归Oracle所有。 3.浏览器的组成:外壳（shell）和内核。内核又分为渲染引擎，js引擎以及其他部分，以下介绍js引擎：2001年发布ie6，首次实现对js引擎的优化。2008年Google发布最新浏览器Chrome，它是采用优化后的javascript引擎，引擎代号V8，因能把js代码直接转化为机械码来执行，进而以速度快而闻名。后Firefox也推出了具备强大功能的js引擎Firefox3.5 TraceMonkey（对频繁执行的代码做了路径优化）Firefox4.0 JeagerMonkey 4.js语言的特点：（1）解释性语言（弱数据类型语言）：翻译一行执行一行。能够跨平台，但是慢（PHP，phthon，JavaScript）编译性语言特点：通篇翻译完之后生成一个文件再执行。很难跨平台执行，但是快。（c，c++）Java是弥补c和c++而出现，先通过javac编译成.class 文件，再通过jvm虚拟机解释执行，所以能够跨平台。（先编译后解释）（2）单线程，同一时间只干一件事儿。轮转时间片：让单线程执行的视觉效果像多线程。切割任务片段，不断往js引擎里送，两个任务还会争抢时间片。（3）ECMA（欧洲计算机联盟）标注：为了获取技术优势，微软推出JScript，CEnvi推出scriptEase，与JavaScript同样可以在浏览器上运行，为了统一规格JavaScript兼容于ECMA标准，因此也称为ECMAscript。 5，JavaScript语言的三大部分 ：ECMAscript，DOM（操作css和HTML），BOM（操作浏览器）。6，JavaScript的引入：（建议用外部引用，因为web标准：结构，样式，行为相分离）（1），页面级JavaScript,标签最优存在的位置body的最下边儿&lt;script type = &quot;text/javascript&quot;&gt;&lt;/script&gt;（2），外部JavaScript引用&lt;script type = &quot;text/javascript&quot; src = &quot;js文件地址&quot;&gt;&lt;/script&gt;js无论以何种方式引用，当读到js标签时，阻塞其他加载项，先加载js，完了之后再加载其他项，所以js文件的最优出生位置为body的最下边儿。 7，变量（variable）：（1）变量声明：var ，声明变量，向系统要一个内存空间，以var后面的值作为内存空间的名字，以便于后面的操作。用等号往内存空间赋值。var a = 123；声明变量a，将123赋值给a。（2）变量名的命名规则：变量名必须与字母 ，’_’，$字符开头；变量名可以包括字母，下划线，$，数字；不可以用系统的关键字和保留字作为变量名。 8，数据类型：（1）原始值（栈数据stack）：数字类型（number），字符串（string），布尔值（Boolean：true/false），undefined（undefined：未定义），null（null：空占位）。（2）引用值（堆数据heap）：数组（array），对象（object），函数（function）。（3）不可改变的原始值：栈数据在改变变量的值的时候，将变量声明的内存空间名还原，再次申请一个内存空间，空间名与以前相同，将值存入，以前的值依然存在于之前的内存空间中。引用值在赋值时，在栈数据结构里申请内存空间，命名a，值为堆数据里的内存空间名。堆数据的内存空间里存引用值的值，相互配合给引用值赋值。假如再声明一个变量b的时候，将a的值赋给b，此时赋的是堆数据的内存空间名。改变堆数据里的数据，则b也改变。 9，JavaScript语句的基本规则：（1）语句后面要以分号结束“；”。（2）js语法错误会引发后续代码终止，但不会影响其他js模块（3）书写规范，运算符两边都要有空格。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>历史</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css基础]]></title>
    <url>%2F2018%2F08%2F07%2Fcss%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[css引入引用css的方式：（cascading style sheet css简称，层叠样式表）（1）行间样式&lt;div style = &quot;&quot;&gt;&lt;/div&gt;（2）页面级css，在head标签里加style标签&lt;style type =&quot;text/css&quot;&gt;&lt;/style&gt;（3）外部css文件&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;css存储地址&quot;&gt; 设置字体样式的属性：（1）font-size: 字体的大小，后bold接像素值，统一的是字体的高。（2）font-weight: 字体的粗细。bold加粗，normal正常，bolder更粗，lighter更细。100~900的整百的像素值，字体逐渐加粗。基本上只有bold和normal好使。（3）font-family : 微软雅黑,宋体, ‘New York’; font-family翻译为中文是“字体家族”，就是告诉浏览器，优先使用哪一种字体，谁排在最前面，就先使用这种字体，这里是“微软雅黑”；还有一个最舒服的字体值为arial。（4）font-style: 值只有italic，设置字体的斜体。（5）color：设置字体文本的颜色。颜色代码：rgb美术三元色，两个码代表一种颜色的值，每个码在16进制中是由0~ff eg：#f40。（每两位重复可简写）。rgb（0,0,238）超链接的蓝色。（5）line-height；值一般为包裹文本元素的高，设置文本垂直居中。align：center；设置文本水平居中。 四大基础选择器：（1）id选择器，css文件中选中用#加id值，一对一的关系（2）class选择器，css文件中选中用 . 加class值，多对多的关系（3）标签选择器，以标签名选中，一对多的关系（4）通配符选择器，以*号选中，作用于整个页面（属性选择器：[class]{}选中有class属性的标签；[class = “”]{}选中有class属性且值为“”的标签） 各种选择器的权重值的比较：123456！important //Infiniti行间样式 //1000id选择器 //100class/属性/伪类 //10标签/伪元素 //1通配符 //0 其他复杂选择器：（1）父子选择器/派生选择器，div p{ }，div下面的p标签都可以选出来。选择器属性值的父子关系也能用。class class{ } ，id id{ }，选择器值和标签名也可以并列使用class div{ }，id div{ }。父子选择器是自右向左找，满足浏览器内部原则，快。写在横行的选择器的权重值相加比较。大的覆盖小的（假如选中同一个元素）（2）直接子元素选择器，div &gt; p{ },div下面的直接的p标签。可以和上面的父子选择器共用。（3）并列选择器。多个条件选中一个元素。 选中：div.demo{ }。可以class和id并，class和class并，id和id。但是当id和class与标签并列的时候，标签应该放前面。并列选择器的权重值也是相加比较。（4）分组选择器，div,strong,em{ }。选中div，strong，em标签都被代码块中的修饰。可以和以上三种一起用，标准写法是逗号后回车换行。（相同代码的共用写法） 盒模型：（1）margin：外边距，盒子与浏览器的距离。（2）border：边框，代码形式：border:1px solid black;border-width:1px; border-style:solid;（3）padding：内边距，内容区和边框之间的距离。（4）content：width*height 内容区面积。盒子本身：border padding content。以上的margin，border，padding都可以单独设置，top，left，right，bottom值。margin和padding和border-left-width可以用像素值，当为四个值时，10px 10px 10px 10px;上右下左的顺序。当为三个值时，10px 10px 10px;上（左右）下的顺序。两个值时是（上下）（左右）。一个值时是设置四个方向的像素值。 常用标签的默认margin值：（1）&lt;body&gt;有默认的8px的margin（2）&lt;div&gt;有默认的16px的margin（3）&lt;p&gt;有默认的16px的margin（4）&lt;ul&gt;有默认的16px的margin和40px的padding-left。（5）&lt;h1&gt;有默认的21.440px的margin 解决：通配符选择器，设置初始化，margin和padding为0。开发过程中先初始化。 margin的两个bug：（1）margin塌陷问题：垂直方向上的margin出问题。不完全解决办法：父级盒子加border-top；解决方法：触发bfc（block format context块级格式化上下文），使盒子内容区符合另一种语法规则。触发bfc的属性：（overflow:hidden）（display:inline-block）（float:left）（position:absolute）（2）margin合并问题：（一般不解决）不改变其HTML结构。eg：当兄弟节点分别设置margin-top和margin-bottom时，上下共用一片margin的最大值。解决方法是一个兄弟节点再套一层结构并触发bfc（改变了HTML结构，所以一般不解决）。 层模型：设置position属性，设置完之后该元素成为可定位元素，配合left（左边线距离浏览器边框的距离），top（上边线距离浏览器边框的距离），还有bottom和right，两两配合使用。后面四个属性单独写没意义，得和定位配合使用。left等四个属性的默认值为auto，相对于出生点。z-index，又称为对象的层叠顺序，它用一个整数来定义堆叠的层次，整数值越大，则被层叠在越上面，当然这是指同级元素间的堆叠，如果两个对象的此属性具有同样的值，那么将依据它们在HTML文档中流的顺序层叠，写在后面的将会覆盖前面的。需要注意的是，父子关系是无法用z-index来设定上下关系的，一定是子级在上父级在下。Note：使用static 定位或无position定位的元素z-index属性是无效的。 position的几个常用属性值：（1）absolute：脱离原来位置进行定位，相对于最近有定位的父级进行定位，如果没有有定位的父级，则相对于文档进行定位。（有定位的层级高），（假如都有定位，后出生的有定位的层级高）（2）relative：相对定位，保留原来的位置进行定位。相对于自己原来的位置进行定位。一般以position：relative作为参照物，以position：absolute来定位。（3）fixed：相对于可视区窗口进行定位。（IE6无fixed定位）eg：拉动滚动条，不影响某些广告在浏览器中的位置。（4）static：默认值。没有定位，元素出现在正常流中。非常用：（1）inherit：规定应该从父元素继承position属性的值（2）initial：关键字用于设置css属性为其默认值，可作用于任何css样式（IE不支持）（3）unset：如果属性是默认继承属性，相当于inherit，默认非继承属性，相当于initial（4）sticky：粘性定位，超出设定的top，bottom，left，right中任意一个，就表现为fixed定位，否则为相对定位。 圆环的css画法：border：10px solid black; border-radius:50%;三角形的css画法：width:0px;height:0px;border:50px solid transparent;border-color:transpare css浮动float属性：有两个属性值left/right 向左/右浮动；浮动的特点：（1）产生浮动流，不独占一行，块级元素看不见浮动元素，所以会占据浮动元素原来的位置。文本，文本类元素（inline，inline-block），触发bfc的元素都能看见浮动元素，并且会排列到浮动元素后面。（2）定位元素对浮动元素无效。（浮动元素相对于同一层面而言）所以也会占据浮动元素原来的位置。 两栏布局：（1）用浮动实现：1234567891011.right&#123; width:100px; height:100px; float:right; background-color:red; &#125;.left&#123; height:100px; margin-right:100px; background-color：green; &#125; （2）用定位实现12345678910111213.right&#123; position:absolute; right:0; top:0; width:100px; height:100px; background-color:red; &#125;.left&#123; height:100px; margin-right:100px ;background-color：green; &#125; 文字环绕图片效果：img标签后加文本内容，给img标签设置浮动，相对于出生点进行向左向右的浮动。 css的清除浮动：（1）逻辑结构后加&lt;div style = &quot;clear:both&quot;&gt;&lt;/div&gt;能够清除浮动，但改变了HTML结构，不可取。（2）伪元素清除浮动 div::after{content:””;clear:both;display:block}。但是在IE6和IE7上无法实现，因为无伪元素。（3）IE6和IE7上的layout机制（类似bfc机制）father{*zoom:1;} fater::after{content:””;display:block;clear:both;} css伪元素天生就有，依赖于元素存在，能像元素一样操作，但没有元素的结构。即为标签中原本的结构是&lt;div&gt;::before 内容 ::after&lt;/div&gt;可以像元素一样操作，伪元素有天生的display为inline。相当于div下有两个行级标签，在css下以div::before{content:”” }的方法选中进行操作。但必须有content属性，设置文本内容，就算是没有文本内容，也得以“”的空形式存在。（IE6和IE7上面无伪元素，无bfc） 常用的css属性（1）display属性：只有inline（行级元素），inline-block（行级块元素），block（块级元素），none（设置后隐藏元素）。 （2）实现文字溢出容器打点：1234white-space：nowrap；//此代码的功能是使文字到达边界时失去换行的功能。text-overflow：ellipsis；//此代码的功能是使文字溢出时展示的样式。多个点儿。overflow:hidden; //三段代码共同作用使得文字溢出打点儿（单行文字溢出打点）多行文字溢出打点无法以技术实现，百度的多行打点是以计算的方式将后面文本以点的方式替换。多行文字只能进行截断处理设置line-height；height；overflow：hidden（行高与容器高度相互配合） （3）背景图片：①background-image:url(图片地址）。作为背景图片引入。②background-repeat:repeat-x(沿x轴重复)，repeat-y(沿Y轴重复)，no-repeat(不重复)，默认值repeat。③background-position:像素值或者百分数；设置50% 50%时直接在容器内居中。（还有left 和top，center，bottom分别配合使用，左上，左中，左下。相应的right也可以。④background-size:像素值； 设置背景图片尺寸。 （4）文本设置：①text-decoration:none(定义标准的文本），underline（文本下的一条线），overline（文本上的一条线），line-through（穿过文本的一条线），blink（闪烁的文本），inherit（从父级继承该属性的值）②text-indent:像素值；设置文本的首行缩进。③vertical-align：像素值或者middle；调整文本的对齐方式（设置浮动的元素无效，浮动元素以margin-top实现）④text-align：left/right/center（左对齐，右对齐和居中）。⑤word-spacing：normal/像素值 设置每个字之间的标准间隔，负值可以拉近文字间隔。litter-spacing和word-spacing的区别在于litter-spacing修改的是字符或者字母间隔。⑥text-transform：none/uppercase/lowercase/capitalize（不改动，全大写，全小写，每个单词首字母大写。⑦line-height：当设置line-height等于容器的高度时，无法严格的垂直居中，此时上边比下边多一像素，可以将行高设置比height高一像素。也可以：{font-size：20px；line-height：20px；height：20px；margin：6px 0；} （5）工业级开发：①当含有链接的图片因为网络问题无法加载时显示文字效果（图片代替文字效果）手动设置容器的高度为0；设置margin-top的值为你想要的像素值，此时图片将在margin区域平铺a标签下文字将在图片下方；再设置overflow：hidden；此时文字隐藏。当网络不好时，无法加载css样式，则文字显现。②文字前的小角标或者后面的小三角拿伪元素做。实现效果：角标 文字 &gt;1234567891011121314151617father::before&#123; display:inline-block; content:&quot;&quot;; width:12px; height:11px; background-size:50% 50%; background-image:url(); &#125;father::after&#123; float:right; display:inline-block; content:&quot;&quot;; width:12px; height:11px; background-size:50% 50%; background-image:url(); &#125; ③内容区不变，两侧留白区在可视区减少时减少。子级设置margin：0 auto； 特例注意：inline-block/块级元素可以嵌套任何元素行级元素可以嵌套行级元素p标签里不能放块级元素a标签里不能放a标签。父子选择器最多不超过四层五层，浪费效率。]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>样式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2018%2F08%2F06%2Fhtml%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTML前端总结 HTML hyperText markup language 超文本链接语言 根标签分头标签和尾标签 eg:&lt;html&gt;&lt;/html&gt; head标签设置给浏览器看的，body标签设置给用户看的。 属性分为属性名和属性值，只能设置在头标签上。 charset属性：①gb2312：国标2312，识别中文，亚洲文字，不包括繁体中文②gbk：国家标准扩展版本，识别繁体中文③Unicode：万国码 utf-8也是万国码。Unicode Transformation Format 8比特 &lt;html lang = &quot;en&quot;&gt;告诉搜索引擎爬虫，网站关于什么内容。SEO 搜索引擎优化 meta标签：head区的一个辅助性标签。一共有两个属性，包括name属性和http-equiv属性，不同的属性有不同的属性值，这些属性值实现了不同的网页功能。以下详细介绍一下两种属性：①name属性：name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 1234&lt;meta name = &quot;keywords&quot; content = &quot;science,education,culture&quot;&gt; //告诉搜索引擎你网页的关键字是什么&lt;meta name = &quot;description&quot; content = &quot;miaoshuneirong&quot;&gt;//网站描述内容&lt;meta name = &quot;robots&quot; content = &quot;&quot;&gt; //机器人向导，告诉搜索机器人哪些页面需要索引&lt;meta name = &quot;author&quot; content = &quot;&quot;&gt; //作者，标注网页的作者 ②http-equiv属性：顾名思义就是相当于http文件头的作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确的显示网页内容。1234567&lt;meta http-equiv = &quot;Expires&quot; content = &quot;&quot;&gt; //用于设定网页的到期时间，一旦网页过期，必须到服务器上重新传输&lt;meta http-equiv = &quot;Pragma&quot; content = &quot;&quot;&gt; //禁止浏览器从本地计算机的缓存中访问页面内容&lt;meta http-equiv = &quot;Refresh&quot; content = &quot;&quot;&gt; //自动刷新并指向新的页面&lt;meta http-equiv = &quot;Set-Cookie&quot; content = &quot;&quot;&gt; //如果网页过期，那么存盘中的cookie将被删除&lt;meta http-equiv = &quot;Window-target&quot; content = &quot;&quot;&gt; //显示窗口的设定，强制页面在当前窗口以独立页面显示，用来防止别人在框架中调用自己的页面&lt;meta http-equiv = &quot;content-type&quot; content = &quot;&quot;&gt;//设定页面显示的字符集&lt;meta http-equiv = &quot;Cache-Control&quot; content = &quot;&quot;&gt; //指定请求和响应遵循的缓存机制。 Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下Public指示响应可被任何缓存区缓存Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效no-cache指示请求或响应消息不能缓存no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 title标签，在head标签里面，修改网页页脚标的文字，logo无法本地添加，挂载服务器时传的图片。 文字分割符：空格和回车，HTML空格编码：&amp;nbsp；，小于编码&amp;lt；，大于编码&amp;gt；。 body区标签：①p， 段落标签，成段展示，里边儿文本成段展示。②h1~h6，字体从大到小，设计字体的大小，独占一行成段展示，标题标签，加粗文字。③strong，加粗文字 em，斜体④address，独占一行，斜体文字，（不常用）⑤i，斜体文字 b，加粗文本 老功能⑥del，文本加横杠，开发中不允许使用，因为下划线既有结构也有样式，css语言中设置text-decoration的值为line-through和上面的能达到一样的功能⑦div，span，重要标签，独占一行，对每个部分进行分类，结构化，功能化，集体操作。div和span的区别:This is crazy，当crazy的字体样式与其他不同时，div套所有文本，而有独特样式crazy可以用span套，设置独特的样式。span是内联的。section标签和div标签相似。⑧br，换行展示a&lt;br&gt;ba和b换换行展示。单标签，自己代表一定功能，不包裹内容⑨hr，水平线⑩ol-li 有序列表，ol上有type属性，值有1（默认），a/A，i/I，排序类型。 reversed属性，值有reversed，逆序排列；start属性，值为数字，从第几个开始排序。ul-li 无序列表 （unorder list ,list item)； 用在：大功能块儿里有很多功能子项。子项除内容不同，样式功能相同。 ①图片引用标签&lt;img src = &quot;&quot; alt = &quot;&quot; title = &quot;&quot;&gt;src后面填图片地址（a，网上的URL，网址链接；b，相对路径，存储地址一样，在同一文件夹下； 绝对路径，整个地址，后两种是本地引用图片）。alt后填写图片的相关描述，当图片无法展示的时候，展示图片的描述内容，图片占位符 title后填写图片提示符（鼠标移动到图片上，显示的内容）②链接标签及其作用&lt;a href = &quot;&quot;&gt;给用户看&lt;/a&gt;href:hyperText reference超文本引用，填目标网站地址，后还有target属性，设置_blank，则点击a标签跳转时空白页打开网址。默认当前页进行跳转。（a）a标签用作锚点用，填写跳转位置的ID值（只能是ID值） 例如：一键置顶。（b）当href值为tel：12345436565；挂载在移动端可以实现点击打电话的功能。当href值为mailto：邮箱地址；点击调用邮件系统，实现发邮件（c）协议限定符：填写javascript：while(1){alert（’陷入死循环’) }&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;js_method()&quot;&gt;&lt;/a&gt;onclick方法负责执行js函数，而void是一个操作符，void(0)返回undefined，地址不发生跳转&lt;a href=&quot;javascript:;&quot; onclick=&quot;js_method()&quot;&gt;&lt;/a&gt;这种方法跟跟上一种类似，区别只是执行了一条空的js代码&lt;a href=&quot;#&quot; onclick=&quot;js_method();return false;&quot;&gt;&lt;/a&gt;点击执行了js函数后return false，页面不发生跳转，执行后还是在页面的当前位置。③表格标签，三层嵌套关系&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table border = &quot;1px&quot; cellpadding = &quot;1px&quot; cellspacing = &quot;1px&quot;&gt;加border展示表格，cellpadding内边距，cellspacing 外边距。td标签中的设置colspan= “3”align = “center”代表独占三列，文字居中。现在很少使用table标签：网页依赖于浏览器执行，服务器访问HTML到本地进行执行（下载过程中，符合最优最快原则）下载一部分执行一部分，而table标签必须将里边的内容下载完成才能执行（体验效果不好）。④form表单，将前端的请求发送到后台，发送数据必须有数据名和数据值12345&lt;form method = &quot;get&quot; action = &quot;发送对象，后台网址&quot;&gt;username：&lt;input type = &quot;text&quot; name = &quot;username&quot;&gt; //name就是数据名，输入的是数据值password：&lt;input type = &quot;password&quot; name = &quot;password&quot;&gt;&lt;input type = &quot;submit&quot;&gt; //提交按钮&lt;/form&gt; 以上代码的实现效果：登录框，扣扣登录框等；⑤input标签：12345&lt;input type = &quot;radio&quot;&gt; //单选框，但不设置相同的name值得话，浏览器无法识别那几个选择框为一道题，则会有多选的效果&lt;input type = &quot;radio&quot; name = &quot;aaa&quot; value = &quot;bbb&quot;&gt; //数据名是aaa，数据值是bbb，此时才能提交。&lt;input type = &quot;checkbox&quot; name = &quot;&quot; value = &quot;&quot;&gt; //复选框。&lt;input type = &quot;radio&quot; name = &quot;&quot; value = &quot;&quot; checked = &quot;checked&quot;&gt;//设置哪个为默认选项，checked属性设置在哪个input标签上，哪个就成为默认选项。&lt;input type = &quot;text&quot; name = &quot;&quot; value = &quot;请输入用户名&quot;&gt; //输入框的提示内容。 重要的输入框：&lt;input type = &quot;text&quot; name = &quot;username&quot; style = &quot;color:#999&quot; value = &quot;请输入用户名&quot; onfocus = &quot;if(this.value == &#39;请输入用户名&#39;){this.value = &#39;&#39;;this.style.color = &#39;#424242&#39;}&quot;onblur = &quot;if(this.value ==&#39;&#39;){this.value = &#39;请输入用户名’;this.style.color = &#39;#999&#39;}&quot;&gt;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客说明]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[本博客用于记录学习笔记，以及对一些前端问题的探讨，因为之前的笔记是写在有道云笔记上的，只能自己看，可能会有很多的不妥之处，无法找出，所以自己搭建了这个博客，将笔记发布，希望大家批评指正。]]></content>
      <categories>
        <category>博客说明</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>导航</tag>
      </tags>
  </entry>
</search>
